<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SparkJoy Editor — Crack Shot (r9 warmup + custom thresholds)</title>
  <style>
    :root{ --bg:#0b0f14; --ink:#e6ecf3; --muted:#9fb3c7; --panel:rgba(255,255,255,0.05); --border:rgba(255,255,255,0.12); }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--ink); font:16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 12px}
    .btn{cursor:pointer; padding:8px 12px; border-radius:10px; border:1px solid var(--border); background:#152030; color:var(--ink)}
    .btn.ghost{background:transparent}
    .card{background:var(--panel); border:1px solid var(--border); border-radius:12px}
    .tabs{display:flex; gap:8px; padding:0 12px 8px}
    .tab{padding:8px 12px; border-radius:999px; border:1px solid var(--border); background:#13202f; color:var(--ink); cursor:pointer}
    .tab.active{background:#1c2a3c}
    #toolbar{margin:0 12px 12px; padding:8px; display:flex; flex-direction:column; gap:10px}
    .bar{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .chip{display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:999px; background:rgba(0,0,0,.25); border:1px solid var(--border)}
    .chip input[type="range"], .chip select{width:140px}
    #editorWrap{margin:0 12px 12px}
    #editor{min-height:48vh; padding:14px; outline:none; white-space:pre-wrap; word-break:break-word}
    #editor[contenteditable="true"]:empty:before{content:"ここに書き始めよう…"; color:var(--muted)}
    #fx{position:fixed; inset:0; pointer-events:none; z-index:1000}
    .toast{position:fixed; left:50%; top:12px; transform:translateX(-50%); padding:8px 12px; border-radius:8px; background:#1f2a3a; color:#e6ecf3; border:1px solid rgba(255,255,255,.15); z-index:2000; opacity:.95}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.45);z-index:3000;display:flex;align-items:center;justify-content:center}
    .modal{min-width:320px;max-width:92vw;padding:16px;border-radius:12px;background:#152030;color:#e6ecf3;border:1px solid rgba(255,255,255,.15);box-shadow:0 10px 30px rgba(0,0,0,.4)}
    .row{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;margin-top:12px}
    .muted{color:#9fb3c7}
    .chip.good{box-shadow:0 0 0 2px rgba(80,200,120,.45) inset}
    .chip.warn{box-shadow:0 0 0 2px rgba(255,200,0,.45) inset}
    .chip.bad{box-shadow:0 0 0 2px rgba(255,72,72,.5) inset}
    #aura{position:fixed;inset:0;pointer-events:none;z-index:900;opacity:0;transition:opacity .18s ease;}
    #aura.warn{opacity:.25;background:radial-gradient(60% 60% at 50% 50%, rgba(255,200,0,.12), rgba(255,150,0,.08), transparent 70%)}
    #aura.bad{opacity:.42;background:radial-gradient(55% 55% at 50% 50%, rgba(255,60,60,.22), rgba(255,0,0,.12) 40%, transparent 72%);animation:pulseBad 600ms ease-in-out infinite alternate}
    @keyframes pulseBad{from{opacity:.32}to{opacity:.5}}
    @keyframes shakeWeak{0%{transform:translate(0,0) rotate(0)}20%{transform:translate(-2px,0) rotate(-.15deg)}40%{transform:translate(2px,0) rotate(.15deg)}60%{transform:translate(-2px,0) rotate(-.15deg)}80%{transform:translate(2px,0) rotate(.15deg)}100%{transform:translate(0,0) rotate(0)}}
    @keyframes shakeStrong{0%{transform:translate(0,0) rotate(0)}15%{transform:translate(-6px,-2px) rotate(-.45deg)}35%{transform:translate(6px,2px) rotate(.45deg)}55%{transform:translate(-7px,0) rotate(-.5deg)}75%{transform:translate(7px,0) rotate(.5deg)}100%{transform:translate(0,0) rotate(0)}}
    body.shake-warn{animation:shakeWeak .28s linear 1}
    body.shake-bad{animation:shakeStrong .45s linear 1}
    #settingsBar{display:none}
    body.tab-settings #settingsBar{display:flex}
    body.tab-settings #statsBar{display:none}
  </style>
</head>
<body class="tab-editor">
  <header>
    <div class="brand">SparkJoy Editor</div>
    <div class="tray">
      <button id="saveBtn" class="btn" type="button">保存</button>
      <button id="clearBtn" class="btn" type="button">全消去</button>
    </div>
  </header>

  <div id="tabs" class="tabs">
    <button class="tab active" data-tab="editor">エディタ</button>
    <button class="tab" data-tab="settings">設定</button>
  </div>

  <div id="toolbar" class="card">
    <div id="statsBar" class="bar">
      <span class="chip"><label>文字数</label><span id="charCount">0</span></span>
      <span class="chip"><label>経過</label><span id="elapsed">00:00</span></span>
      <span class="chip"><label>文字/分</label><span id="cpm">0</span></span>
      <span class="chip"><label>平均WPM</label><span id="wpmAvg">0</span></span>
      <span class="chip"><label for="mode">モード</label>
        <select id="mode">
          <option value="write">執筆</option>
          <option value="revise">推敲</option>
        </select>
      </span>
      <span id="idleChip" class="chip"><label>停止比</label><span id="idlePct">0%</span></span>
      <span class="chip"><label>ハイスコア</label><span id="bestTime">00:00</span></span>
      <button id="resetSessionBtn" class="btn ghost" type="button">セッションリセット</button>
    </div>

    <div id="settingsBar" class="bar">
      <span class="chip"><label for="intensity">エフェクト大きさ</label>
        <input id="intensity" type="range" min="0" max="100" value="15"><span id="ival">15</span>
      </span>
      <span class="chip"><label><input id="toggleFx" type="checkbox" checked> エフェクト</label></span>
      <span class="chip"><label><input id="toggleSound" type="checkbox" checked> サウンド</label></span>
      <span class="chip"><label for="soundVol">音量</label>
        <input id="soundVol" type="range" min="0" max="100" value="90"><span id="sval">90</span>
      </span>
      <span class="chip"><label for="realism">リアル度</label>
        <input id="realism" type="range" min="0" max="100" value="100"><span id="rval">100</span>
      </span>
      <span class="chip"><label for="reverb">リバーブ</label>
        <input id="reverb" type="range" min="0" max="100" value="85"><span id="revval">85</span>
      </span>
      <span class="chip"><label for="jam">ジャム確率</label>
        <input id="jam" type="range" min="0" max="100" value="20"><span id="jamval">20</span>
      </span>
      <span class="chip"><label for="autoReset">無操作リセット</label>
        <select id="autoReset">
          <option value="0">OFF</option>
          <option value="30">30秒</option>
          <option value="60">1分</option>
          <option value="180" selected>3分</option>
          <option value="300">5分</option>
          <option value="600">10分</option>
        </select>
      </span>
      <span class="chip"><label for="warnTh">黄しきい値(CPM)</label>
        <input id="warnTh" type="range" min="40" max="240" value="80"><span id="warnVal">80</span>
      </span>
      <span class="chip"><label for="badTh">赤しきい値(CPM)</label>
        <input id="badTh" type="range" min="50" max="300" value="100"><span id="badVal">100</span>
      </span>
      <span class="chip"><label for="warmupSec">ウォームアップ</label>
        <input id="warmupSec" type="range" min="0" max="20" value="6"><span id="warmVal">6s</span>
      </span>
      <span class="chip"><small class="muted">※ ウォームアップ中は黄/赤になりません</small></span>
    </div>
  </div>

  <div id="editorWrap" class="card">
    <div id="editor" contenteditable="true" spellcheck="false"></div>
  </div>

  <canvas id="fx"></canvas>
  <div id="aura" aria-hidden="true"></div>

<script>
(()=>{'use strict';
  // ===== DOM =====
  const $ = (id)=>document.getElementById(id);
  const editor = $('editor');
  const saveBtn = $('saveBtn');
  const clearBtn = $('clearBtn');
  const intensityEl = $('intensity');
  const ival = $('ival');
  const toggleFx = $('toggleFx');
  const toggleSound = $('toggleSound');
  const soundVolEl = $('soundVol');
  const sval = $('sval');
  const realismEl = $('realism');
  const rval = $('rval');
  const reverbEl = $('reverb');
  const revval = $('revval');
  const jamEl = $('jam');
  const jamval = $('jamval');
  const presetSel = $('preset'); // （存在しない場合は null のまま）
  const charCountEl = $('charCount');
  const elapsedEl = $('elapsed');
  const cpmEl = $('cpm');
  const wpmAvgEl = $('wpmAvg');
  const modeSel = $('mode');
  const idlePctEl = $('idlePct');
  const idleChip = $('idleChip');
  const bestTimeEl = $('bestTime');
  const resetSessionBtn = $('resetSessionBtn');
  const aura = $('aura');
  const canvas = $('fx');
  const ctx = canvas.getContext('2d');
  const tabs = document.querySelectorAll('#tabs .tab');
  const autoResetSel = $('autoReset');
  const warnEl = $('warnTh');
  const badEl = $('badTh');
  const warmupEl = $('warmupSec');
  const warnVal = $('warnVal');
  const badVal = $('badVal');
  const warmVal = $('warmVal');

  // ===== Canvas / DPR =====
  let DPR = 1;
  function resizeCanvas(){
    DPR = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // ===== Tabs =====
  tabs.forEach(btn=>btn.addEventListener('click', ()=>{
    tabs.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    const tab = btn.getAttribute('data-tab');
    document.body.classList.toggle('tab-settings', tab==='settings');
    document.body.classList.toggle('tab-editor', tab!=='settings');
  }));

  // ===== Storage helpers =====
  const LS = { high:'sj_highscore_sec', auto:'sj_auto_reset_sec', warn:'sj_warn_cpm', bad:'sj_bad_cpm', warm:'sj_warmup_sec' };
  const loadNum = (k, def)=>{ try{ const v=parseInt(localStorage.getItem(k)||String(def),10); return isNaN(v)? def : v; }catch(_){ return def; } };
  const saveNum = (k, v)=>{ try{ localStorage.setItem(k, String(v)); }catch(_){ } };
  function loadHigh(){ return loadNum(LS.high,0); }
  function saveHigh(sec){ saveNum(LS.high, Math.max(0,Math.floor(sec))); }
  function loadAuto(){ return loadNum(LS.auto,180); }
  function saveAuto(sec){ saveNum(LS.auto, sec); }
  function loadWarn(){ return loadNum(LS.warn,80); }
  function saveWarn(v){ saveNum(LS.warn, v); }
  function loadBad(){ return loadNum(LS.bad,100); }
  function saveBad(v){ saveNum(LS.bad, v); }
  function loadWarm(){ return loadNum(LS.warm,6); }
  function saveWarm(v){ saveNum(LS.warm, v); }

  warnEl.value = String(loadWarn());
  badEl.value = String(loadBad());
  warmupEl.value = String(loadWarm());

  // ===== Settings UI =====
  function refreshUI(){
    ival.textContent = intensityEl.value;
    sval.textContent = soundVolEl.value;
    rval.textContent = realismEl.value;
    revval.textContent = reverbEl.value;
    jamval.textContent = jamEl.value;
    warnVal.textContent = warnEl.value;
    badVal.textContent = badEl.value;
    warmVal.textContent = warmupEl.value+'s';
  }
  ;[intensityEl,soundVolEl,realismEl,reverbEl,jamEl].forEach(el=>el.addEventListener('input',refreshUI));
  warnEl.addEventListener('input', ()=>{ refreshUI(); saveWarn(warnEl.value); });
  badEl.addEventListener('input',  ()=>{ refreshUI(); saveBad(badEl.value); });
  warmupEl.addEventListener('input',()=>{ refreshUI(); saveWarm(warmupEl.value); });

  function markCustom(){ try{ if(presetSel) presetSel.value='custom'; }catch(_){ } }
  ;[intensityEl, soundVolEl, realismEl, reverbEl, jamEl, warnEl, badEl, warmupEl, toggleFx, toggleSound].forEach(el=>{
    el && el.addEventListener('input' in el ? 'input':'change', markCustom);
  });

  const PRESETS = {
    deep:    {name:'Deep Focus', fx:true,  sound:true,  intensity:60, volume:45, realism:85, reverb:15, jam:0, warn:70, bad:90, warm:4},
    flow:    {name:'Flow',       fx:true,  sound:true,  intensity:70, volume:55, realism:65, reverb:30, jam:5, warn:85, bad:110, warm:3},
    zen:     {name:'Zen',        fx:true,  sound:true,  intensity:40, volume:35, realism:40, reverb:50, jam:0, warn:75, bad:95, warm:8},
    silent:  {name:'Silent',     fx:true,  sound:false, intensity:50, volume:0,  realism:70, reverb:0,  jam:0, warn:80, bad:100, warm:6},
    playful: {name:'Playful',    fx:true,  sound:true,  intensity:80, volume:60, realism:45, reverb:25, jam:0, warn:80, bad:120, warm:2}
  };
  function applyPreset(key){
    const p = PRESETS[key]; if(!p) return;
    toggleFx.checked = !!p.fx; toggleSound.checked = !!p.sound;
    intensityEl.value = String(p.intensity);
    soundVolEl.value  = String(p.volume);
    realismEl.value   = String(p.realism);
    reverbEl.value    = String(p.reverb);
    jamEl.value       = String(p.jam);
    warnEl.value      = String(p.warn ?? warnEl.value);
    badEl.value       = String(p.bad ?? badEl.value);
    warmupEl.value    = String(p.warm ?? warmupEl.value);
    saveWarn(warnEl.value); saveBad(badEl.value); saveWarm(warmupEl.value);
    if(presetSel) presetSel.value = key;
    refreshUI(); toast('プリセット: ' + (p.name||key)); updateStats();
  }
  if(presetSel){ presetSel.addEventListener('change', ()=>{ const key=presetSel.value; if(key!=='custom') applyPreset(key); }); }
  refreshUI();

  // ===== Typing stats =====
  let typingStart = null;
  let statsTimer = null;
  let baseChars = 0;
  let lastCountLen = 0;
  const ROLL_MS = 60000;
  let cDeltaBuf = [];
  let lastInputAt = 0;
  const ACTIVE_MS = 2000;
  const IDLE_WINDOW = 60;
  let activityBuf = new Array(IDLE_WINDOW).fill(false);
  let activityIdx = 0;
  const MODE = { write:{warn:80, bad:100}, revise:{min:30, max:70} };
  function setChipClass(el, cls){ if(!el) return; el.classList.remove('good','warn','bad'); if(cls) el.classList.add(cls); }
  function setAura(level){ if(!aura) return; aura.classList.remove('warn','bad'); if(level==='warn') aura.classList.add('warn'); else if(level==='bad') aura.classList.add('bad'); }
  function bumpShake(level){ try{ document.body.classList.remove('shake-warn','shake-bad'); void document.body.offsetWidth; document.body.classList.add(level==='bad'?'shake-bad':'shake-warn'); }catch(_){} }

  function getThresholds(){
    let warn = parseInt(warnEl.value,10)||80;
    let bad  = parseInt(badEl.value,10)||100;
    if(warn >= bad){ bad = warn + 1; badEl.value = String(bad); }
    warnVal.textContent = String(warn); badVal.textContent = String(bad);
    return {warn, bad};
  }

  function updateModeFeedback(cpm){
    const wrap = cpmEl && cpmEl.parentElement; if(!wrap) return;
    setChipClass(wrap, null);

    const warm = parseInt(warmupEl.value,10)||0;
    if(typingStart){
      const since = (performance.now() - typingStart)/1000;
      if(since < warm){
        setAura(null); window.__lastSpeedLevel = 'none'; return;
      }
    }

    const mode = modeSel ? modeSel.value : 'write';
    let level = 'none';
    if(mode==='revise'){
      const th = MODE.revise;
      if(cpm > th.max) level='bad';
      else if(cpm < th.min) level='warn';
      else level='good';
    } else {
      const th = getThresholds();
      if(cpm >= th.bad) level='bad';
      else if(cpm >= th.warn) level='warn';
      else level='none';
    }

    if(level==='good') setChipClass(wrap,'good');
    else if(level==='warn') setChipClass(wrap,'warn');
    else if(level==='bad') setChipClass(wrap,'bad');
    setAura(level==='warn' ? 'warn' : (level==='bad' ? 'bad' : null));

    const now=performance.now();
    const justTyped = (now - lastInputAt) < 220;
    if((level==='bad' || level==='warn') && justTyped){
      const cooldown = (level==='bad') ? 1500 : 2500;
      if(level !== window.__lastSpeedLevel || !window.__lastShakeAt || (now - window.__lastShakeAt) > cooldown){
        bumpShake(level); window.__lastShakeAt = now;
      }
    }
    window.__lastSpeedLevel = level;
  }

  function formatTime(sec){
    const s = Math.floor(sec%60).toString().padStart(2,'0');
    const m = Math.floor((sec/60)%60).toString().padStart(2,'0');
    const h = Math.floor(sec/3600);
    return (h>0? h+':':'')+m+':'+s;
  }
  function seconds(){ return performance.now()/1000; }

  let highSec = loadHigh();
  function showHigh(){ if(bestTimeEl) bestTimeEl.textContent = formatTime(highSec); }
  function updateHigh(elapsedSec){ if(elapsedSec>highSec){ highSec = Math.floor(elapsedSec); saveHigh(highSec); showHigh(); toast('ハイスコア更新: '+formatTime(highSec)); } }
  showHigh();

  let autoResetSec = loadAuto();
  autoResetSel.value = String(autoResetSec);
  autoResetSel.addEventListener('change', ()=>{ autoResetSec = parseInt(autoResetSel.value,10)||0; saveAuto(autoResetSec); });

  function endSession(reason){
    const now = performance.now();
    if(typingStart){ const elapsedSec = (now-typingStart)/1000; updateHigh(elapsedSec); }
    typingStart = null; baseChars = 0; cDeltaBuf.length=0; activityBuf.fill(false);
    lastCountLen = sanitizeText(editor.innerText||'').length; updateStats();
    window.__lastSpeedLevel = 'none'; window.__lastShakeAt = 0; setAura(null);
    if(reason==='idle' && autoResetSec>0) toast('無操作でセッションをリセット');
  }

  function updateStats(){
    const text = sanitizeText(editor.innerText||'');
    const totalLen = text.length;
    if(charCountEl) charCountEl.textContent = String(totalLen);

    const now = performance.now();
    if(typingStart && autoResetSec>0 && (now - lastInputAt) > autoResetSec*1000){ endSession('idle'); }

    if(!typingStart){
      if(elapsedEl) elapsedEl.textContent='00:00';
      if(cpmEl) cpmEl.textContent='0';
      if(wpmAvgEl) wpmAvgEl.textContent='0';
      if(idlePctEl) idlePctEl.textContent='0%';
      setChipClass(idleChip,null); setChipClass(cpmEl && cpmEl.parentElement, null);
      return;
    }

    const elapsed = (now-typingStart)/1000;
    if(elapsedEl) elapsedEl.textContent = formatTime(elapsed);

    const cutoff = now - ROLL_MS;
    while(cDeltaBuf.length && cDeltaBuf[0].t < cutoff){ cDeltaBuf.shift(); }
    let sum = 0; for(const s of cDeltaBuf){ sum += s.c; }
    const spanSec = Math.max(1, Math.min(ROLL_MS/1000, elapsed));
    const cpm = Math.round(sum * 60 / spanSec);
    if(cpmEl) cpmEl.textContent = String(cpm);
    if(wpmAvgEl) wpmAvgEl.textContent = String(Math.round((sum/5) * 60 / spanSec));

    const activeNow = (now - lastInputAt) < ACTIVE_MS;
    activityBuf[activityIdx] = activeNow; activityIdx = (activityIdx+1)%IDLE_WINDOW;
    const valid = activityBuf.length; let act=0; for(const b of activityBuf){ if(b) act++; }
    const idlePct = Math.round((1 - act/valid)*100);
    if(idlePctEl) idlePctEl.textContent = idlePct + '%';
    if(modeSel && modeSel.value==='revise'){
      if(idlePct < 20) setChipClass(idleChip,'bad');
      else if(idlePct < 40) setChipClass(idleChip,'warn');
      else setChipClass(idleChip,'good');
    } else {
      setChipClass(idleChip, null);
    }
    updateModeFeedback(cpm);
  }
  function startStatsIfNeeded(){
    if(!typingStart){
      typingStart = performance.now();
      try{ lastCountLen = baseChars = sanitizeText(editor.innerText||'').length; }
      catch(_){ lastCountLen = baseChars = 0; }
      if(statsTimer) clearInterval(statsTimer);
      statsTimer = setInterval(updateStats, 1000);
    }
  }
  updateStats();

  // ===== Crack effect =====
  const cracks = [];
  const flashes = [];
  function spawnCrack(x,y){
    if(!toggleFx.checked) return;
    const I = Math.max(0, Math.min(100, +intensityEl.value||0));
    const rays = Math.max(3, Math.round(5 + I*0.12 + (window.__lastSpeedLevel==='bad'? 6 : 0)));
    const lenBase = 40 + I*2.4;
    const widthBase = 1 + I*0.035 + (window.__lastSpeedLevel==='bad'? 0.6 : 0);
    const life = 70 + Math.round(I*1.4);
    const branchProb = 0.18 + I*0.003 + (window.__lastSpeedLevel==='bad'? 0.02 : 0);
    const segs = [];
    for(let r=0;r<rays;r++){
      const baseAng = Math.random()*Math.PI*2;
      const steps = 6 + Math.floor(Math.random()*5);
      let px = x, py = y;
      for(let i=0;i<steps;i++){
        const ang = baseAng + (Math.random()-0.5)*0.35;
        const stepLen = (lenBase/steps) * (0.9 + Math.random()*0.2);
        const nx = px + Math.cos(ang)*stepLen;
        const ny = py + Math.sin(ang)*stepLen;
        const w = Math.max(0.7, widthBase - i*0.35);
        segs.push({x1:px,y1:py,x2:nx,y2:ny,w,age:0,life: life*(0.85+Math.random()*0.3)});
        if(Math.random()<branchProb && i>1){
          const bang = ang + (Math.random()<0.5?1:-1)*(0.6+Math.random()*0.5);
          const bl = stepLen*(0.5+Math.random()*0.9);
          segs.push({x1:nx,y1:ny,x2:nx+Math.cos(bang)*bl,y2:ny+Math.sin(bang)*bl,w:Math.max(0.6,w*0.75),age:0,life: life*0.8});
        }
        px = nx; py = ny;
      }
    }
    cracks.push({segments:segs});
  }
  function drawCracks(){
    ctx.clearRect(0,0,window.innerWidth, window.innerHeight);
    for(let c=cracks.length-1;c>=0;c--){
      const crack = cracks[c];
      let allDead = true;
      for(const s of crack.segments){
        s.age = (s.age||0) + 1;
        if(s.age < s.life) allDead = false;
        const t = Math.min(1, s.age/s.life);
        const alpha = 1 - t;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = Math.max(0.5, s.w * (1 - t*0.6));
        ctx.strokeStyle = '#c9d6df';
        ctx.beginPath(); ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke();
        ctx.globalAlpha = alpha*0.35; ctx.lineWidth = Math.max(0.4, (s.w-0.6)); ctx.strokeStyle = '#111821'; ctx.stroke();
        ctx.globalAlpha = 1;
      }
      if(allDead) cracks.splice(c,1);
    }
    for(let i=flashes.length-1;i>=0;i--){
      const f=flashes[i]; f.age=(f.age||0)+1; const t=f.age/f.life; const alpha=(1-t)*(1-t);
      const r = f.size*(0.7+0.6*t);
      const grd = ctx.createRadialGradient(f.x,f.y,0,f.x,f.y,r);
      grd.addColorStop(0, `rgba(255,140,80,${0.25*alpha})`);
      grd.addColorStop(0.35,`rgba(255,60,60,${0.22*alpha})`);
      grd.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = grd; ctx.globalCompositeOperation='lighter';
      ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.fill();
      ctx.globalCompositeOperation='source-over';
      if(f.age>=f.life) flashes.splice(i,1);
    }
  }
  (function loop(){ drawCracks(); requestAnimationFrame(loop); })();

  // ===== Audio =====
  let audioCtx = null; let noiseBuf = null; let irs = null;
  function buildAudioAssets(){
    const a = audioCtx; if(!a) return; const sr = a.sampleRate;
    noiseBuf = a.createBuffer(1, Math.floor(sr*1), sr);
    const ch = noiseBuf.getChannelData(0);
    for(let i=0;i<ch.length;i++){ ch[i] = Math.random()*2-1; }
    function makeIR(seconds, decay){
      const len = Math.max(1, Math.floor(sr*seconds));
      const buf = a.createBuffer(2, len, sr);
      for(let c=0;c<2;c++){
        const d = buf.getChannelData(c);
        let lp = 0;
        for(let i=0;i<len;i++){
          const t = i/sr; const amp = Math.exp(-t*decay);
          lp = 0.98*lp + 0.02*(Math.random()*2-1);
          d[i] = ((Math.random()*2-1)*0.7 + lp*0.3) * amp;
        }
      }
      return buf;
    }
    irs = { room: makeIR(0.35, 8), hall: makeIR(1.10, 3.3), plate: makeIR(0.70, 6) };
  }
  function ensureAudio(){ if(!audioCtx){ const AC = window.AudioContext||window.webkitAudioContext; audioCtx = new AC(); buildAudioAssets(); } }
  function resumeAudio(){ try{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }catch(_){} }

  window.__gunVariants = [
    {name:'pistol_close',   crackHz:2600, crackQ:0.9, crackDur:0.06, thumpHz:90,  thumpDur:0.22, pingHz:0,    tail:'room',  tailMix:0.25},
    {name:'pistol_room',    crackHz:1900, crackQ:0.8, crackDur:0.08, thumpHz:85,  thumpDur:0.28, pingHz:1400, tail:'hall',  tailMix:0.38},
    {name:'revolver_snap',  crackHz:3200, crackQ:1.2, crackDur:0.05, thumpHz:110, thumpDur:0.20, pingHz:2200, tail:'plate', tailMix:0.28},
    {name:'distant_crack',  crackHz:2400, crackQ:0.7, crackDur:0.07, thumpHz:70,  thumpDur:0.18, pingHz:0,    tail:'hall',  tailMix:0.45, postLP:3500}
  ];

  // ===== Typing speed tracking =====
  let __sparkjoyKeyTimes = [];
  const WPM_WINDOW_MS = 2000;
  function markKeystroke(){
    const now = performance.now();
    __sparkjoyKeyTimes.push(now);
    const cutoff = now - WPM_WINDOW_MS;
    while(__sparkjoyKeyTimes.length && __sparkjoyKeyTimes[0] < cutoff){ __sparkjoyKeyTimes.shift(); }
  }
  function getWPM(){
    const now = performance.now();
    const cutoff = now - WPM_WINDOW_MS;
    let count = 0; for(let i=__sparkjoyKeyTimes.length-1;i>=0;i--){ if(__sparkjoyKeyTimes[i] >= cutoff) count++; else break; }
    const cps = count / (WPM_WINDOW_MS/1000);
    const wpm = (cps/5) * 60;
    return wpm || 0;
  }
  function mapWPM(wpm){
    const low=20, high=100;
    const tRaw = (wpm - low) / (high - low);
    const t = Math.max(0, Math.min(1, tRaw));
    const durMul = 1.0 - 0.4*t;
    const wetMul = 1.0 - 0.5*t;
    const pingMul = 1.0 - 0.6*t;
    return {t, durMul, wetMul, pingMul};
  }
  window.__sparkjoyWPM = getWPM; window.__mapWPM = mapWPM;

  function playGunshot(){
    if(!toggleSound.checked) return;
    ensureAudio(); resumeAudio();
    const a = audioCtx; const now = a.currentTime; const UIvol = (+soundVolEl.value/100);
    const R = Math.max(0, Math.min(1, (+realismEl.value||0)/100));
    const RV = Math.max(0, Math.min(1, (+reverbEl.value||0)/100));
    const v = window.__gunVariants[Math.floor(Math.random()*window.__gunVariants.length)];
    const crackDur = Math.max(0.03, Math.min(0.2, v.crackDur * (1.4 - 0.7*R)));
    const crackQ   = v.crackQ * (0.7 + 0.9*R);
    const thDur    = v.thumpDur * (0.8 + 0.4*R);
    const thAmp    = 0.8 + 0.4*R;
    const pingAmp  = v.pingHz ? (0.30 * (1 - 0.85*R)) : 0;
    const wetMix   = (v.tailMix||0.3) * (0.25 + 0.75*R) * (0.2 + 1.8*RV);
    const wpm = getWPM(); const m = mapWPM(wpm);
    const crackDur2 = crackDur * m.durMul; const thDur2= thDur * m.durMul; const pingAmp2= pingAmp * m.pingMul; const wetMix2 = wetMix * m.wetMul;
    const panNode = a.createStereoPanner ? a.createStereoPanner() : null;
    if(panNode){ const pan = (lastCaret.x/window.innerWidth - 0.5)*1.6; panNode.pan.setValueAtTime(Math.max(-1,Math.min(1,pan)), now); }
    const comp = a.createDynamicsCompressor();
    comp.threshold.setValueAtTime(-20 - 8*R, now);
    comp.knee.setValueAtTime(18 + 8*R, now);
    comp.ratio.setValueAtTime(2.5 + 3.0*R, now);
    comp.attack.setValueAtTime(0.003 - 0.001*R, now);
    comp.release.setValueAtTime(0.18 - 0.05*R, now);
    const out = a.createGain(); out.gain.setValueAtTime(UIvol, now);
    const crackSrc = a.createBufferSource(); crackSrc.buffer = noiseBuf; crackSrc.playbackRate.setValueAtTime(1+(Math.random()*0.2-0.1), now);
    const crackBP = a.createBiquadFilter(); crackBP.type='bandpass'; crackBP.frequency.setValueAtTime(v.crackHz, now); crackBP.Q.setValueAtTime(crackQ, now);
    const crackGain = a.createGain(); crackGain.gain.setValueAtTime(0.0001, now); crackGain.gain.exponentialRampToValueAtTime(1.0+0.2*R, now+0.002); crackGain.gain.exponentialRampToValueAtTime(0.0001, now+crackDur2);
    crackSrc.connect(crackBP).connect(crackGain);
    const thOsc = a.createOscillator(); thOsc.type='triangle'; thOsc.frequency.setValueAtTime(v.thumpHz, now);
    const thGain = a.createGain(); thGain.gain.setValueAtTime(thAmp, now); thGain.gain.exponentialRampToValueAtTime(0.0001, now+thDur2);
    thOsc.connect(thGain);
    let pingOsc=null, pingGain=null; if(v.pingHz && pingAmp2>0){ pingOsc=a.createOscillator(); pingOsc.type='square'; pingOsc.frequency.setValueAtTime(v.pingHz*(0.95+Math.random()*0.1), now); pingGain=a.createGain(); pingGain.gain.setValueAtTime(pingAmp2, now); pingGain.gain.exponentialRampToValueAtTime(0.0001, now+0.12); pingOsc.connect(pingGain); }
    const dry = a.createGain(); const wet = a.createGain();
    dry.gain.setValueAtTime(1, now); wet.gain.setValueAtTime(Math.min(1.0, wetMix2*UIvol), now);
    const conv = a.createConvolver(); conv.buffer = irs ? irs[v.tail] : null;
    const sum = a.createGain();
    crackGain.connect(sum); thGain.connect(sum); if(pingGain) pingGain.connect(sum);
    let post = null; if(v.postLP){ post = a.createBiquadFilter(); post.type='lowpass'; post.frequency.setValueAtTime(v.postLP, now); }
    sum.connect(dry); sum.connect(conv); conv.connect(wet);
    const head = a.createGain(); head.gain.setValueAtTime(1, now);
    const compOut = (dry.connect(comp), wet.connect(comp), comp);
    const last = post ? (head.connect(post), post) : head;
    compOut.connect(head);
    if(panNode){ last.connect(panNode).connect(out).connect(a.destination); } else { last.connect(out).connect(a.destination); }
    crackSrc.start(now); crackSrc.stop(now + crackDur2 + 0.02);
    thOsc.start(now);   thOsc.stop (now + thDur2 + 0.05);
    if(pingOsc){ pingOsc.start(now); pingOsc.stop(now + 0.15); }
  }
  ['pointerdown','keydown'].forEach(ev=>window.addEventListener(ev,()=>{ensureAudio();resumeAudio();},{once:true}));

  // ===== Caret =====
  let lastCaret = {x: window.innerWidth/2, y: window.innerHeight/2};
  function caretClientPoint(){
    const sel = window.getSelection();
    if(!sel || sel.rangeCount===0){ return lastCaret; }
    const range = sel.getRangeAt(0).cloneRange();
    range.collapse(true);
    let rect = range.getClientRects()[0] || range.getBoundingClientRect();
    if(!rect || !(rect.width || rect.height)){
      const span = document.createElement('span');
      span.style.display='inline-block'; span.style.width='0'; span.style.height='1em';
      span.textContent='\u200b';
      range.insertNode(span);
      rect = span.getBoundingClientRect();
      const restore = document.createRange(); restore.setStartAfter(span); restore.collapse(true);
      const sel2 = window.getSelection(); sel2.removeAllRanges(); sel2.addRange(restore);
      span.parentNode && span.parentNode.removeChild(span);
    }
    const x = rect.left + rect.width/2; const y = rect.top + rect.height/2; lastCaret = {x,y}; return lastCaret;
  }

  // ===== IME（composition）対策 ここが今回の修正ポイント =====
  let isComposing = false;
  let compBaseLen = 0;
  let lastCompFxAt = 0; // ← 追加：変換中のFX/SFXを間引くためのタイムスタンプ

  editor.addEventListener('compositionstart', ()=>{
    isComposing = true;
    compBaseLen = sanitizeText(editor.innerText||'').length;
  });

  editor.addEventListener('compositionend', ()=>{
    // 確定したぶんだけ一括加算
    const now = performance.now();
    const lenNow = sanitizeText(editor.innerText||'').length;
    const delta = Math.max(0, lenNow - compBaseLen);
    lastCountLen = lenNow; // 同期
    isComposing = false;

    if(delta > 0){
      cDeltaBuf.push({ t: now, c: delta });
      const cutoff = now - ROLL_MS;
      while(cDeltaBuf.length && cDeltaBuf[0].t < cutoff){ cDeltaBuf.shift(); }
      lastInputAt = now;
      // 視覚・音は確定で1回だけ
      const p = caretClientPoint();
      spawnCrack(p.x, p.y);
      if(window.__lastSpeedLevel==='bad'){ flashes.push({x:p.x,y:p.y,age:0,life:36,size:240*(Math.max(0.6,(+intensityEl.value)/100))}); }
      else if(window.__lastSpeedLevel==='warn'){ flashes.push({x:p.x,y:p.y,age:0,life:22,size:160*(Math.max(0.6,(+intensityEl.value)/100))}); }
      playGunshot();
      startStatsIfNeeded(); updateStats();
    } else {
      // 変換で文字数が増えなかった場合でも表示は更新
      updateStats();
    }
  });

  function crackAtCaret(){
    const jamP = Math.max(0, Math.min(1, (+jamEl.value||0)/100));
    if (Math.random() < jamP) { return; }
    const p = caretClientPoint();
    spawnCrack(p.x, p.y);
    if(window.__lastSpeedLevel==='bad'){ flashes.push({x:p.x,y:p.y,age:0,life:36,size:240*(Math.max(0.6,(+intensityEl.value)/100))}); }
    else if(window.__lastSpeedLevel==='warn'){ flashes.push({x:p.x,y:p.y,age:0,life:22,size:160*(Math.max(0.6,(+intensityEl.value)/100))}); }
    playGunshot();
  }

  // ▼ ここが変更点：IME中はカウントせずにFX/SFXだけ鳴らす
  if (isComposing || isCompType) {
    const lenBefore = lastCountLen;   // 直前の長さ（比較用）
    lastCountLen = lenNow;            // 表示上の文字数は同期（カウントは積まない）
    lastInputAt = now;

    // 変換中でも寂しくならないように FX/SFX を出す（挿入系/増加時のみ＆60msスロットル）
    const isInsertish = type.startsWith('insert') || lenNow > lenBefore;
    if (isInsertish && (now - lastCompFxAt) > 60) {
      crackAtCaret();                  // ここで Jam 確率も適用されます
      lastCompFxAt = now;
    }

    startStatsIfNeeded();              // 経過タイマーは動かす
    updateStats();                     // ただし CPM/WPM の積算は行わない
    return;                            // ← ここで抜ける
  }

    // 通常入力：増分を積算（減った分は 0 扱い）
    const added = Math.max(0, lenNow - lastCountLen);
    lastCountLen = lenNow;

    if (!isPaste && added > 0) {
      cDeltaBuf.push({ t: now, c: added });
      const cutoff = now - ROLL_MS;
      while (cDeltaBuf.length && cDeltaBuf[0].t < cutoff) { cDeltaBuf.shift(); }
    }

    lastInputAt = now;
    if (!isPaste && added > 0) { markKeystroke(); crackAtCaret(); }
    startStatsIfNeeded(); updateStats();
  }

  editor.addEventListener('input', onInput);
  if(modeSel){ modeSel.addEventListener('change', ()=>{ updateStats(); }); }
  editor.addEventListener('focus', ()=>{ lastCaret = caretClientPoint(); });
  editor.setAttribute('role','textbox'); editor.setAttribute('aria-multiline','true'); editor.focus();

  // ===== Utils / Save / Clear（変更なし） =====
  function toast(msg){ try{ const t=document.createElement('div'); t.className='toast'; t.textContent=msg; document.body.appendChild(t); setTimeout(()=>t.remove(),1400);}catch(_){} }
  function sanitizeText(t){ return String(t||'').replace(/[​﻿]/g, ''); }
  function makeFilename(){ return `sparkjoy_${new Date().toISOString().replace(/[:.]/g,'-')}.txt`; }
  const IN_CANVAS = (function(){ try { return window.self !== window.top; } catch(_){ return true; } })();

  function showSavePanel(text, filename){ /* …（元のまま）… */ }
  function showSaveFallback(text, filename){ /* …（元のまま）… */ }
  function buildSaveHTML(text, filename){ const title=String(filename||'sparkjoy.txt').replace(/[&<>]/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[m])); return '<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><title>'+title+'</title></head><body><pre>'+String(text).replace(/[&<>]/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[m]))+'</pre></body></html>'; }
  function openWriterTab(text, filename){ /* …（元のまま）… */ }
  async function saveNow(text){ /* …（元のまま）… */ }

  function bindReliableClick(el, handler){ /* …（元のまま）… */ }
  function askClear(){ /* …（元のまま）… */ }
  function doClear(){ /* …（元のまま）… */ }

  bindReliableClick(saveBtn, ()=>{ const plain=sanitizeText(editor.innerText||''); const fname = makeFilename(); if (IN_CANVAS) { /* パネル */ } else { void saveNow(plain); } });
  bindReliableClick(clearBtn, ()=>{ askClear(); });
  bindReliableClick(resetSessionBtn, ()=>{ endSession('manual'); });

  // ===== Self tests =====
  window.__sparkjoyTest = function(){
    const report=[];
    try{
      report.push(editor? 'OK: editor':'NG: editor');
      report.push(canvas && ctx? 'OK: canvas':'NG: canvas');
      // simulate simple type
      const base = sanitizeText(editor.innerText||'').length;
      const before = cracks.length;
      editor.innerText = (editor.innerText||'') + 'x';
      onInput({inputType:'insertText'});
      report.push(cracks.length>before? 'OK: エフェクト':'NG: エフェクト');
      report.push((charCountEl && parseInt(charCountEl.textContent,10) >= base+1)? 'OK: 文字数':'NG: 文字数');
      // paste-safe
      const beforeSum = cpmEl? parseInt(cpmEl.textContent||'0',10):0;
      editor.innerText += 'PASTE_TEXT';
      onInput({inputType:'insertFromPaste'});
      const afterSum = cpmEl? parseInt(cpmEl.textContent||'0',10):0;
      report.push(afterSum>=beforeSum? 'OK: paste-safe':'NG: paste inflated');
      // idle reset quick
      const now = performance.now();
      autoResetSel.value = '0'; // avoid interference
      // --- IME simulation: composition should count once ---
      const len0 = sanitizeText(editor.innerText||'').length;
      editor.dispatchEvent(new Event('compositionstart'));
      editor.innerText = (editor.innerText||'') + 'あ'; // preedit-like change
      onInput({inputType:'insertCompositionText', isComposing:true});
      editor.dispatchEvent(new Event('compositionend'));
      const len1 = sanitizeText(editor.innerText||'').length;
      report.push((len1===len0+1)? 'OK: IME length once':'NG: IME length mismatch');
    }catch(e){ report.push('NG: 例外 '+(e&&e.message?e.message:e)); }
    return report;
  };
  window.__onInput = onInput;
})();</script>
</body>
</html>

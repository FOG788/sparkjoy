<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <link rel="manifest" href="./manifest.json?v=20250813-3">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="SparkJoy">
  <title>SparkJoy Editor — Crack Shot (r9 warmup + custom thresholds)</title>
  <style>
    :root{ --bg:#0b0f14; --ink:#e6ecf3; --muted:#9fb3c7; --panel:rgba(255,255,255,0.05); --border:rgba(255,255,255,0.12); }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--ink); font:16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 12px; position:relative; z-index:10}
    .btn{cursor:pointer; padding:8px 12px; border-radius:10px; border:1px solid var(--border); background:#152030; color:var(--ink)}
    .btn.ghost{background:transparent}
    .card{background:var(--panel); border:1px solid var(--border); border-radius:12px}
    .tabs{display:flex; gap:8px; padding:0 12px 8px}
    .tab{padding:8px 12px; border-radius:999px; border:1px solid var(--border); background:#13202f; color:var(--ink); cursor:pointer}
    .tab.active{background:#1c2a3c}
    #toolbar{margin:0 12px 12px; padding:8px; display:flex; flex-direction:column; gap:10px}
    .bar{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .chip{display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:999px; background:rgba(0,0,0,.25); border:1px solid var(--border)}
    .chip input[type="range"], .chip select{width:140px}
    #editorWrap{margin:0 12px 12px}
    #editor{min-height:48vh; padding:14px; outline:none; white-space:pre-wrap; word-break:break-word}
    #editor[contenteditable="true"]:empty:before{content:"ここに書き始めよう…"; color:var(--muted)}
    #fx{position:fixed; inset:0; pointer-events:none; z-index:1000}
    .toast{position:fixed; left:50%; top:12px; transform:translateX(-50%); padding:8px 12px; border-radius:8px; background:#1f2a3a; color:#e6ecf3; border:1px solid rgba(255,255,255,.15); z-index:2000; opacity:.95}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.45);z-index:3000;display:flex;align-items:center;justify-content:center}
    .modal{min-width:320px;max-width:92vw;padding:16px;border-radius:12px;background:#152030;color:#e6ecf3;border:1px solid rgba(255,255,255,.15);box-shadow:0 10px 30px rgba(0,0,0,.4)}
    .row{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;margin-top:12px}
    .muted{color:#9fb3c7}
    .chip.good{box-shadow:0 0 0 2px rgba(80,200,120,.45) inset}
    .chip.warn{box-shadow:0 0 0 2px rgba(255,200,0,.45) inset}
    .chip.bad{box-shadow:0 0 0 2px rgba(255,72,72,.5) inset}
    #aura{position:fixed;inset:0;pointer-events:none;z-index:900;opacity:0;transition:opacity .18s ease;}
    #aura.warn{opacity:.25;background:radial-gradient(60% 60% at 50% 50%, rgba(255,200,0,.12), rgba(255,150,0,.08), transparent 70%)}
    #aura.bad{opacity:.42;background:radial-gradient(55% 55% at 50% 50%, rgba(255,60,60,.22), rgba(255,0,0,.12) 40%, transparent 72%);animation:pulseBad 600ms ease-in-out infinite alternate}
    @keyframes pulseBad{from{opacity:.32}to{opacity:.5}}
    @keyframes shakeWeak{0%{transform:translate(0,0) rotate(0)}20%{transform:translate(-2px,0) rotate(-.15deg)}40%{transform:translate(2px,0) rotate(.15deg)}60%{transform:translate(-2px,0) rotate(-.15deg)}80%{transform:translate(2px,0) rotate(.15deg)}100%{transform:translate(0,0) rotate(0)}}
    @keyframes shakeStrong{0%{transform:translate(0,0) rotate(0)}15%{transform:translate(-6px,-2px) rotate(-.45deg)}35%{transform:translate(6px,2px) rotate(.45deg)}55%{transform:translate(-7px,0) rotate(-.5deg)}75%{transform:translate(7px,0) rotate(.5deg)}100%{transform:translate(0,0) rotate(0)}}
    body.shake-warn{animation:shakeWeak .28s linear 1}
    body.shake-bad{animation:shakeStrong .45s linear 1}
    #settingsBar{display:none}
    body.tab-settings #settingsBar{display:flex}
    body.tab-settings #statsBar{display:none}
    @media (display-mode: standalone) { header { padding-top: calc(env(safe-area-inset-top) + 6px); } }
    /* ==== タイプライターモード用スペーサ ==== */
    :root{
      /* 好みで調整（中央キープのための余白） */
      --tw-top: 18vh;     /* 上側のダミー余白 */
      --tw-bottom: 46vh;  /* 下側のダミー余白（大きめに） */
    }
    #editor::before,
    #editor::after{
      content:"";
      display:block;
      pointer-events:none;
    }    
    #editor::before{ height: var(--tw-top); }
    #editor::after{  height: var(--tw-bottom); }

  </style>
</head>
<body class="tab-editor">
  <header>
    <div class="brand">SparkJoy Editor</div>
    <div class="tray">
      <button id="saveBtn" class="btn" type="button">保存</button>
      <button id="copyBtn" class="btn" type="button">コピー</button>
      <button id="clearBtn" class="btn" type="button">全消去</button>
    </div>
  </header>

  <div id="tabs" class="tabs">
    <button class="tab active" data-tab="editor">エディタ</button>
    <button class="tab" data-tab="settings">設定</button>
  </div>

  <div id="toolbar" class="card">
    <div id="statsBar" class="bar">
      <span class="chip"><label>文字数</label><span id="charCount">0</span></span>
      <span class="chip"><label>経過</label><span id="elapsed">00:00</span></span>
      <span class="chip"><label>文字/分</label><span id="cpm">0</span></span>
      <span class="chip"><label>平均WPM</label><span id="wpmAvg">0</span></span>
      <span class="chip"><label for="mode">モード</label>
        <select id="mode">
          <option value="write">執筆</option>
          <option value="revise">推敲</option>
        </select>
      </span>
      <span id="idleChip" class="chip"><label>停止比</label><span id="idlePct">0%</span></span>
      <span class="chip"><label>ハイスコア</label><span id="bestTime">00:00</span></span>
      <button id="resetSessionBtn" class="btn ghost" type="button">セッションリセット</button>
    </div>

    <div id="settingsBar" class="bar">
      <span class="chip">
        <label for="fontSize">文字サイズ</label>
        <input id="fontSize" type="range" min="12" max="28" step="1" value="16">
        <span id="fsVal">16px</span>
      </span>
      
      <span class="chip"><label for="intensity">エフェクト大きさ</label>
        <input id="intensity" type="range" min="0" max="100" value="15"><span id="ival">15</span>
      </span>
      <span class="chip"><label><input id="toggleFx" type="checkbox" checked> エフェクト</label></span>
      <span class="chip"><label><input id="toggleSound" type="checkbox" checked> サウンド</label></span>
      <span class="chip"><label for="soundVol">音量</label>
        <input id="soundVol" type="range" min="0" max="100" value="90"><span id="sval">90</span>
      </span>
      <span class="chip"><label for="realism">リアル度</label>
        <input id="realism" type="range" min="0" max="100" value="100"><span id="rval">100</span>
      </span>
      <span class="chip"><label for="reverb">リバーブ</label>
        <input id="reverb" type="range" min="0" max="100" value="85"><span id="revval">85</span>
      </span>
      <span class="chip"><label for="jam">ジャム確率</label>
        <input id="jam" type="range" min="0" max="100" value="20"><span id="jamval">20</span>
      </span>
      <span class="chip"><label for="autoReset">無操作リセット</label>
        <select id="autoReset">
          <option value="0">OFF</option>
          <option value="30">30秒</option>
          <option value="60">1分</option>
          <option value="180" selected>3分</option>
          <option value="300">5分</option>
          <option value="600">10分</option>
        </select>
      </span>
      <span class="chip"><label for="warnTh">黄しきい値(CPM)</label>
        <input id="warnTh" type="range" min="40" max="240" value="80"><span id="warnVal">80</span>
      </span>
      <span class="chip"><label for="badTh">赤しきい値(CPM)</label>
        <input id="badTh" type="range" min="50" max="300" value="100"><span id="badVal">100</span>
      </span>
      <span class="chip"><label for="warmupSec">ウォームアップ</label>
        <input id="warmupSec" type="range" min="0" max="20" value="10"><span id="warmVal">10s</span>
      </span>
      <span class="chip"><small class="muted">※ ウォームアップ中は黄/赤になりません</small></span>
    </div>
  </div>

  <div id="editorWrap" class="card">
    <div id="editor" contenteditable="true" spellcheck="false"></div>
  </div>

  <canvas id="fx"></canvas>
  <div id="aura" aria-hidden="true"></div>

<script>

async function saveWithPicker(text, fname){
  try {
    const handle = await window.showSaveFilePicker({
      suggestedName: fname,
      types: [{ description: 'Text', accept: { 'text/plain': ['.txt'] } }]
    });
    const w = await handle.createWritable();
    await w.write(new Blob([text], { type: 'text/plain;charset=utf-8' }));
    await w.close();
    toast('保存しました（ダウンロードではなく指定場所に保存）');
    return true;
  } catch (e) {
    if (e && (e.name === 'AbortError' || e.code === 20)) {
      toast('保存をキャンセルしました');
      return false;
    }
    return false;
  }
}

function isStandalone() {
  // iOS Safari: navigator.standalone, それ以外: display-mode
  return (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches)
         || (typeof navigator !== 'undefined' && (navigator.standalone === true));
}

async function tryShareFile(text, filename) {
  if (!navigator.share) return false;
  try {
    const file = new File([text], filename, { type: 'text/plain' });
    if (!navigator.canShare || navigator.canShare({ files: [file] })) {
      await navigator.share({ files: [file], title: filename });
      toast('共有を開きました'); 
      return true;
    }
  } catch (e) {
    // ユーザーが閉じた等は静かに無視
  }
  return false;
}

// 環境判定（iOS / standalone）
function isIOS() {
  const ua = navigator.userAgent || '';
  const iDevice = /iPad|iPhone|iPod/.test(ua);
  const iPadOS  = (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  return iDevice || iPadOS;
}
// ---- a[download] で即時ダウンロード（同期タスク内で実行）----
function forceDownload(text, filename) {
  const blob = new Blob([text], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.rel = 'noopener';
  document.body.appendChild(a);
  a.click();              // ← ここが同期で走ることが重要（iOS）
  // 片付けは次のタスクで
  setTimeout(() => {
    try { URL.revokeObjectURL(url); } catch(_) {}
    try { a.remove(); } catch(_) {}
  }, 0);
}


// iOS を含む全プラットフォーム共通：Blob を a[download] で一発ダウンロード
function downloadViaAnchor(text, filename){
  const blob = new Blob([text], { type: 'application/octet-stream' }); // 強制DL
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.rel = 'noopener';
  document.body.appendChild(a);
  a.click(); // 1回だけ
  setTimeout(()=>{ try{URL.revokeObjectURL(url);}catch(_){} try{document.body.removeChild(a);}catch(_){} },0);
}




/* すでに toast があれば何もしない。無ければグローバルに定義 */
// ---- トースト（グローバル） ----
window.toast ||= function (msg) {
  try {
    const t = document.createElement('div');
    t.className = 'toast';
    t.textContent = String(msg);
    document.body.appendChild(t);
    setTimeout(() => t.remove(), 1400);
  } catch (_) { console.log('[toast]', msg); }
};

function makeFilename(){
  return `sparkjoy_${new Date().toISOString().replace(/[:.]/g,'-')}.txt`;
}
window.makeFilename = makeFilename; // 念のため外にも公開

// 共有シートやパネルに逃げず、iPadでも必ずダウンロードを試みる保存フロー
async function saveText(text) {
  const fname = makeFilename();

  if (isIOS()) {
    // iOS はユーザー操作直後の同期で a.click() するのが最も確実
    forceDownload(text, fname);
    toast('ダウンロードを開始しました');
    return true;
  }

  if (window.showSaveFilePicker) {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: fname,
        types: [{ description: 'Text', accept: { 'text/plain': ['.txt'] } }]
      });
      const w = await handle.createWritable();
      await w.write(new Blob([text], { type: 'text/plain;charset=utf-8' }));
      await w.close();
      toast('保存しました');
      return true;
    } catch (e) {
      // ユーザーキャンセルは何もしない（二重DL防止）
      if (e && (e.name === 'AbortError' || e.code === 20)) {
        toast('保存をキャンセルしました');
        return false;
      }
      // それ以外のエラーのみ、1回だけDLにフォールバック
    }
  }
  forceDownload(text, fname);
  toast('ダウンロードを開始しました');
  return true;
}



(()=>{'use strict';

  const $ = (id)=>document.getElementById(id);
  const editor=$('editor'), saveBtn=$('saveBtn'), clearBtn=$('clearBtn'), copyBtn=$('copyBtn');
  const fontEl=$('fontSize'), fsVal=$('fsVal');
  const intensityEl=$('intensity'), ival=$('ival'), toggleFx=$('toggleFx'), toggleSound=$('toggleSound');
  const soundVolEl=$('soundVol'), sval=$('sval'), realismEl=$('realism'), rval=$('rval'), reverbEl=$('reverb'), revval=$('revval');
  const jamEl=$('jam'), jamval=$('jamval'), presetSel=$('preset');
  const charCountEl=$('charCount'), elapsedEl=$('elapsed'), cpmEl=$('cpm'), wpmAvgEl=$('wpmAvg'), modeSel=$('mode');
  const idlePctEl=$('idlePct'), idleChip=$('idleChip'), bestTimeEl=$('bestTime'), resetSessionBtn=$('resetSessionBtn');
  const aura=$('aura'), canvas=$('fx'), ctx=canvas.getContext('2d');
  const tabs=document.querySelectorAll('#tabs .tab'), autoResetSel=$('autoReset');
  const warnEl=$('warnTh'), badEl=$('badTh'), warmupEl=$('warmupSec'), warnVal=$('warnVal'), badVal=$('badVal'), warmVal=$('warmVal');
  

  // Canvas DPR
  function resizeCanvas(){ const DPR=window.devicePixelRatio||1; canvas.width=innerWidth*DPR|0; canvas.height=innerHeight*DPR|0; canvas.style.width=innerWidth+'px'; canvas.style.height=innerHeight+'px'; ctx.setTransform(DPR,0,0,DPR,0,0); }
  addEventListener('resize', resizeCanvas); resizeCanvas();

  // Tabs
  tabs.forEach(btn=>btn.addEventListener('click',()=>{tabs.forEach(b=>b.classList.remove('active'));btn.classList.add('active');const tab=btn.dataset.tab;document.body.classList.toggle('tab-settings',tab==='settings');document.body.classList.toggle('tab-editor',tab!=='settings');}));

  // Storage helpers
  const LS={high:'sj_highscore_sec',auto:'sj_auto_reset_sec',warn:'sj_warn_cpm',bad:'sj_bad_cpm',warm:'sj_warmup_sec',fs:'sj_font_px'};
  const loadNum=(k,def)=>{try{const v=parseInt(localStorage.getItem(k)||String(def),10);return isNaN(v)?def:v}catch(_){return def}};
  const saveNum=(k,v)=>{try{localStorage.setItem(k,String(v))}catch(_){ }};
  const loadHigh=()=>loadNum(LS.high,0), saveHigh=(s)=>saveNum(LS.high,Math.max(0,Math.floor(s)));
  const loadAuto=()=>loadNum(LS.auto,180), saveAuto=(s)=>saveNum(LS.auto,s);
  const loadWarn=()=>loadNum(LS.warn,75),  saveWarn=(v)=>saveNum(LS.warn,v);
  const loadBad =()=>loadNum(LS.bad,110),  saveBad =(v)=>saveNum(LS.bad,v);
  const loadWarm=()=>loadNum(LS.warm,12),   saveWarm=(v)=>saveNum(LS.warm,v);
  const loadFs  =()=>loadNum(LS.fs,16),     saveFs  =(v)=>saveNum(LS.fs,v);

  function applyFont(px){
    const v = Math.max(10, Math.min(40, +px||16));
    if (editor) editor.style.fontSize = v + 'px';
    if (fsVal)  fsVal.textContent    = v + 'px';
  }
  applyFont(loadFs());
  
  warnEl.value=String(loadWarn()); badEl.value=String(loadBad()); warmupEl.value=String(loadWarm());
  if (fontEl) fontEl.value = String(loadFs());
      
function refreshUI(){ ival.textContent=intensityEl.value; sval.textContent=soundVolEl.value; rval.textContent=realismEl.value; revval.textContent=reverbEl.value; jamval.textContent=jamEl.value; warnVal.textContent=warnEl.value; badVal.textContent=badEl.value; warmVal.textContent=warmupEl.value+'s'; if(fontEl&&fsVal) fsVal.textContent=fontEl.value+'px'; }
      ;[intensityEl,soundVolEl,realismEl,reverbEl,jamEl].forEach(el=>el.addEventListener('input',refreshUI));
      fontEl && fontEl.addEventListener('input', ()=>{
        applyFont(fontEl.value);
        saveFs(+fontEl.value||16);
        // 文字サイズ変更後にキャレット位置の再補正（タイプライターモードの揺れ防止）
        if (typeof scheduleTW==='function') scheduleTW();
      });
  warnEl.addEventListener('input',()=>{refreshUI();saveWarn(warnEl.value)});
  badEl .addEventListener('input',()=>{refreshUI();saveBad (badEl.value)});
  warmupEl.addEventListener('input',()=>{refreshUI();saveWarm(warmupEl.value)});
  function markCustom(){try{if(presetSel) presetSel.value='custom';}catch(_){}}; [intensityEl,soundVolEl,realismEl,reverbEl,jamEl,warnEl,badEl,warmupEl,toggleFx,toggleSound,fontEl].forEach(el=>el&&el.addEventListener(('input'in el)?'input':'change',markCustom));
  refreshUI();

  // Stats
  let typingStart=null, statsTimer=null, baseChars=0, lastCountLen=0;
  const ROLL_MS=60000; let cDeltaBuf=[];
  let lastInputAt=0; const ACTIVE_MS=2000, IDLE_WINDOW=60;
  let activityBuf=new Array(IDLE_WINDOW).fill(false), activityIdx=0;
  const MODE={write:{warn:80,bad:100},revise:{min:30,max:70}};
  function setChipClass(el,cls){if(!el)return;el.classList.remove('good','warn','bad'); if(cls) el.classList.add(cls);}
  function setAura(level){ if(!aura) return; aura.classList.remove('warn','bad'); if(level==='warn') aura.classList.add('warn'); else if(level==='bad') aura.classList.add('bad'); }
  function bumpShake(level){ try{ document.body.classList.remove('shake-warn','shake-bad'); void document.body.offsetWidth; document.body.classList.add(level==='bad'?'shake-bad':'shake-warn'); }catch(_){} }
  function getThresholds(){ let warn=parseInt(warnEl.value,10)||80, bad=parseInt(badEl.value,10)||100; if(warn>=bad){bad=warn+1; badEl.value=String(bad);} warnVal.textContent=warn; badVal.textContent=bad; return{warn,bad}; }

  function updateModeFeedback(cpm){
    const wrap=cpmEl&&cpmEl.parentElement; if(!wrap) return; setChipClass(wrap,null);
    const warm=parseInt(warmupEl.value,10)||0;
    if(typingStart){ const since=(performance.now()-typingStart)/1000; if(since<warm){ setAura(null); window.__lastSpeedLevel='none'; return; } }
    const mode=modeSel?modeSel.value:'write'; let level='none';
    if(mode==='revise'){ const th=MODE.revise; if(cpm>th.max) level='bad'; else if(cpm<th.min) level='warn'; else level='good'; }
    else { const th=getThresholds(); if(cpm>=th.bad) level='bad'; else if(cpm>=th.warn) level='warn'; }
    if(level==='good') setChipClass(wrap,'good'); else if(level==='warn') setChipClass(wrap,'warn'); else if(level==='bad') setChipClass(wrap,'bad');
    setAura(level==='warn'?'warn':(level==='bad'?'bad':null));
    const now=performance.now(), justTyped=(now-lastInputAt)<220;
    if((level==='bad'||level==='warn') && justTyped){
      const cooldown=(level==='bad')?1500:2500;
      if(level!==window.__lastSpeedLevel || !window.__lastShakeAt || (now-window.__lastShakeAt)>cooldown){ bumpShake(level); window.__lastShakeAt=now; }
    }
    window.__lastSpeedLevel=level;
  }
  const formatTime=(sec)=>{const s=(sec%60|0).toString().padStart(2,'0'), m=((sec/60|0)%60).toString().padStart(2,'0'), h=(sec/3600|0); return (h>0?h+':':'')+m+':'+s; };

  let highSec=loadHigh(); const showHigh=()=>{if(bestTimeEl) bestTimeEl.textContent=formatTime(highSec)}; showHigh();
  function updateHigh(elapsedSec){ if(elapsedSec>highSec){ highSec=elapsedSec|0; saveHigh(highSec); showHigh(); toast('ハイスコア更新: '+formatTime(highSec)); } }

  let autoResetSec=loadAuto(); autoResetSel.value=String(autoResetSec);
  autoResetSel.addEventListener('change',()=>{autoResetSec=parseInt(autoResetSel.value,10)||0; saveAuto(autoResetSec);});

  function endSession(reason){
    const now=performance.now();
    if(typingStart){ updateHigh((now-typingStart)/1000); }
    typingStart=null; baseChars=0; cDeltaBuf.length=0; activityBuf.fill(false);
    lastCountLen=sanitizeText(editor.innerText||'').length; updateStats();
    window.__lastSpeedLevel='none'; window.__lastShakeAt=0; setAura(null);
    if(reason==='idle'&&autoResetSec>0) toast('無操作でセッションをリセット');
  }

  function updateStats(){
    const text=sanitizeText(editor.innerText||''); const totalLen=text.length; if(charCountEl) charCountEl.textContent=String(totalLen);
    const now=performance.now(); if(typingStart && autoResetSec>0 && (now-lastInputAt)>autoResetSec*1000){ endSession('idle'); }
    if(!typingStart){ elapsedEl&&(elapsedEl.textContent='00:00'); cpmEl&&(cpmEl.textContent='0'); wpmAvgEl&&(wpmAvgEl.textContent='0'); idlePctEl&&(idlePctEl.textContent='0%'); setChipClass(idleChip,null); setChipClass(cpmEl&&cpmEl.parentElement,null); return; }
    const elapsed=(now-typingStart)/1000; elapsedEl&&(elapsedEl.textContent=formatTime(elapsed));
    const cutoff=now-ROLL_MS; while(cDeltaBuf.length && cDeltaBuf[0].t<cutoff){ cDeltaBuf.shift(); }
    let sum=0; for(const s of cDeltaBuf){ sum+=s.c; }
    const spanSec=Math.max(1, Math.min(ROLL_MS/1000, elapsed)); const cpm=Math.round(sum*60/spanSec);
    cpmEl&&(cpmEl.textContent=String(cpm)); wpmAvgEl&&(wpmAvgEl.textContent=String(Math.round((sum/5)*60/spanSec)));
    const activeNow=(now-lastInputAt)<ACTIVE_MS; activityBuf[activityIdx]=activeNow; activityIdx=(activityIdx+1)%IDLE_WINDOW;
    let act=0; for(const b of activityBuf){ if(b) act++; } const idlePct=Math.round((1-act/activityBuf.length)*100);
    idlePctEl&&(idlePctEl.textContent=idlePct+'%');
    if(modeSel&&modeSel.value==='revise'){ if(idlePct<20) setChipClass(idleChip,'bad'); else if(idlePct<40) setChipClass(idleChip,'warn'); else setChipClass(idleChip,'good'); } else setChipClass(idleChip,null);
    updateModeFeedback(cpm);
  }
  function startStatsIfNeeded(){
    if(!typingStart){ typingStart=performance.now(); try{ lastCountLen=baseChars=sanitizeText(editor.innerText||'').length; }catch(_){ lastCountLen=baseChars=0; }
      if(statsTimer) clearInterval(statsTimer); statsTimer=setInterval(updateStats,1000);
    }
  }
  updateStats();

  // Crack effect
  const cracks=[], flashes=[], holes=[];
  function spawnCrack(x,y){
    if(!toggleFx.checked) return;
    const I=Math.max(0,Math.min(100,+intensityEl.value||0));
    const rays=Math.max(3, Math.round(5+I*0.12+(window.__lastSpeedLevel==='bad'?6:0)));
    const lenBase=40+I*2.4, widthBase=1+I*0.035+(window.__lastSpeedLevel==='bad'?0.6:0);
    const life=70+Math.round(I*1.4), branchProb=0.18+I*0.003+(window.__lastSpeedLevel==='bad'?0.02:0);
    const segs=[];
    for(let r=0;r<rays;r++){
      const baseAng=Math.random()*Math.PI*2, steps=6+Math.floor(Math.random()*5);
      let px=x, py=y;
      for(let i=0;i<steps;i++){
        const ang=baseAng+(Math.random()-0.5)*0.35, stepLen=(lenBase/steps)*(0.9+Math.random()*0.2);
        const nx=px+Math.cos(ang)*stepLen, ny=py+Math.sin(ang)*stepLen, w=Math.max(0.7, widthBase-i*0.35);
        segs.push({x1:px,y1:py,x2:nx,y2:ny,w,age:0,life:life*(0.85+Math.random()*0.3)});
        if(Math.random()<branchProb && i>1){
          const bang=ang+(Math.random()<0.5?1:-1)*(0.6+Math.random()*0.5), bl=stepLen*(0.5+Math.random()*0.9);
          segs.push({x1:nx,y1:ny,x2:nx+Math.cos(bang)*bl,y2:ny+Math.sin(bang)*bl,w:Math.max(0.6,w*0.75),age:0,life:life*0.8});
        }
        px=nx; py=ny;
      }
    }
    cracks.push({segments:segs});
  }
  function spawnSingleImpactAround(cx, cy, opts = {}) {
  if (!toggleFx.checked) return;

  const I = Math.max(0, Math.min(100, +intensityEl.value || 0));
  const level = window.__lastSpeedLevel || 'none';

  // 半径は強度とスピードで少しだけ変化
  const rBase  = opts.radius ?? (24 + I * 1.1 + (level === 'bad' ? 10 : 0));
  const jitter = opts.jitter ?? (rBase * 0.4);

  const ang = Math.random() * Math.PI * 2;
  const r   = Math.max(6, rBase + (Math.random() * 2 - 1) * jitter);

  const x = cx + Math.cos(ang) * r;
  const y = cy + Math.sin(ang) * r;

  // 既存のひび割れ 1つだけ
  spawnCrack(x, y);

  // 小さめフラッシュ（眩しいなら消してOK）
  flashes.push({
    x, y,
    age: 0,
    life: (level === 'bad' ? 18 : 14),
    size: 80 * Math.max(0.5, (+intensityEl.value) / 100)
  });

  // クレーター機能を入れている場合だけ追加（無ければ無視される）
  if (typeof addHole === 'function') addHole(x, y);
}

  function addHole(x, y) {
    holes.push({
      x, y,
      r: 5 + Math.random() * 9,         // クレーター半径
      age: 0,
      life: 60 + (Math.random() * 40|0) // だいたい1～1.6秒くらいで薄れる（60fps想定）
      });
  }
      
      /**
      * カーソル周囲に円形（半径r）でランダムに複数の着弾をばら撒く
      * @param {number} cx 中心x（キャレット）
      * @param {number} cy 中心y（キャレット）
      * @param {object} opts { count, radius, jitter }
      */
  function spawnCrackRing(cx, cy, opts = {}) {
    if (!toggleFx.checked) return;
    
    const I = Math.max(0, Math.min(100, +intensityEl.value || 0));     // UIの「エフェクト大きさ」
    const level = window.__lastSpeedLevel || 'none';
    
    // 着弾数：強度と速度で増やす
    const count = opts.count ?? ( (level === 'bad' ? 5 : 3) + Math.floor(2 + I / 35) );
    
    // 基準半径：強度と速度で変化
    const rBase = opts.radius ?? (26 + I * 1.3 + (level === 'bad' ? 12 : 0));
    const jitter = opts.jitter ?? (rBase * 0.4); // 半径のバラつき
    
    for (let i = 0; i < count; i++) {
      const ang = Math.random() * Math.PI * 2;
      const r   = Math.max(8, rBase + (Math.random() * 2 - 1) * jitter);
      const x   = cx + Math.cos(ang) * r;
      const y   = cy + Math.sin(ang) * r;
      
      spawnCrack(x, y);   // 既存のひび割れ発生
      addHole(x, y);      // 小クレーター
      
      // 小さめのフラッシュ（眩しすぎると感じたらこの行を消してOK）
      if (Math.random() < 0.85) {
        flashes.push({
          x, y,
          age: 0,
          life: 14,
          size: 70 * Math.max(0.5, (+intensityEl.value) / 100)
        });
      }
    }
  }
      
  function drawCracks(){
    ctx.clearRect(0,0,innerWidth,innerHeight);
    for(let c=cracks.length-1;c>=0;c--){
      const crack=cracks[c]; let allDead=true;
      for(const s of crack.segments){
        s.age=(s.age||0)+1; if(s.age<s.life) allDead=false;
        const t=Math.min(1,s.age/s.life), alpha=1-t;
        ctx.globalAlpha=alpha; ctx.lineWidth=Math.max(0.5, s.w*(1-t*0.6)); ctx.strokeStyle='#c9d6df';
        ctx.beginPath(); ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke();
        ctx.globalAlpha=alpha*0.35; ctx.lineWidth=Math.max(0.4,(s.w-0.6)); ctx.strokeStyle='#111821'; ctx.stroke();
        ctx.globalAlpha=1;
      }
      if(allDead) cracks.splice(c,1);
    }
    for (let i = holes.length - 1; i >= 0; i--) {
      const h = holes[i];
      h.age = (h.age || 0) + 1;
      const t = Math.min(1, h.age / h.life);
      const alpha = (1 - t) * 0.75;       // だんだん薄く
      const r = h.r * (0.9 + 0.25 * t);   // ほんの少し広がる
      
      const grd = ctx.createRadialGradient(h.x, h.y, 0, h.x, h.y, r);
      grd.addColorStop(0.0, `rgba(0,0,0,${0.70 * alpha})`);
      grd.addColorStop(0.5, `rgba(20,20,20,${0.45 * alpha})`);
      grd.addColorStop(1.0, `rgba(0,0,0,0)`);
      
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(h.x, h.y, r, 0, Math.PI * 2); ctx.fill();
      
      if (h.age >= h.life) holes.splice(i, 1);
    }
    for(let i=flashes.length-1;i>=0;i--){
      const f=flashes[i]; f.age=(f.age||0)+1; const t=f.age/f.life, alpha=(1-t)*(1-t), r=f.size*(0.7+0.6*t);
      const grd=ctx.createRadialGradient(f.x,f.y,0,f.x,f.y,r);
      grd.addColorStop(0,`rgba(255,140,80,${0.25*alpha})`); grd.addColorStop(0.35,`rgba(255,60,60,${0.22*alpha})`); grd.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle=grd; ctx.globalCompositeOperation='lighter'; ctx.beginPath(); ctx.arc(f.x,f.y,r,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over';
      if(f.age>=f.life) flashes.splice(i,1);
    }
    requestAnimationFrame(drawCracks);
  }
  requestAnimationFrame(drawCracks);

  // Audio
  // ======== Audio Samples (MP3) =========
// GitHub Pages のプロジェクトサイトなので相対パスでOK（./sounds/～）
let gunshotSampleUrls = [
  './sounds/9mm-pistol-shoot-short-reverb-7152.mp3',
  './sounds/9mm-pistol-shot-6349.mp3',
  './sounds/gunshot-352466.mp3',
  './sounds/pistol-shot-233473.mp3'
];

let gunshotBuffers = [];   // AudioBuffer[]
let gunshotReady = false;

async function loadGunshotSamples() {
  if (!audioCtx) return;         // AudioContextがまだなら後で再挑戦
  if (gunshotReady) return;      // 既にロード済みならスキップ
  try {
    const decodes = await Promise.all(
      gunshotSampleUrls.map(async (url) => {
        const res = await fetch(url, { cache: 'force-cache' });
        const arr = await res.arrayBuffer();
        return await audioCtx.decodeAudioData(arr);
      })
    );
    gunshotBuffers = decodes.filter(Boolean);
    gunshotReady = gunshotBuffers.length > 0;
    console.log('[gunshots] loaded', gunshotBuffers.length);
  } catch (e) {
    console.warn('[gunshots] load failed', e);
    gunshotReady = false;
  }
}
  let audioCtx=null, noiseBuf=null, irs=null;
  function buildAudioAssets(){
    const a=audioCtx; if(!a) return; const sr=a.sampleRate;
    noiseBuf=a.createBuffer(1, Math.floor(sr*1), sr);
    const ch=noiseBuf.getChannelData(0); for(let i=0;i<ch.length;i++){ ch[i]=Math.random()*2-1; }
    function makeIR(seconds,decay){
      const len=Math.max(1,Math.floor(sr*seconds)), buf=a.createBuffer(2,len,sr);
      for(let c=0;c<2;c++){ const d=buf.getChannelData(c); let lp=0;
        for(let i=0;i<len;i++){ const t=i/sr, amp=Math.exp(-t*decay); lp=0.98*lp+0.02*(Math.random()*2-1); d[i]=((Math.random()*2-1)*0.7+lp*0.3)*amp; } }
      return buf;
    }
    irs={room:makeIR(0.35,8), hall:makeIR(1.10,3.3), plate:makeIR(0.70,6)};
  }
  function ensureAudio(){ if(!audioCtx){ const AC=window.AudioContext||window.webkitAudioContext; audioCtx=new AC(); buildAudioAssets(); } }
  function resumeAudio(){ try{ if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }catch(_){} }
  window.__gunVariants=[
    {name:'pistol_close', crackHz:2600, crackQ:0.9, crackDur:0.06, thumpHz:90, thumpDur:0.22, pingHz:0,    tail:'room',  tailMix:0.25},
    {name:'pistol_room',  crackHz:1900, crackQ:0.8, crackDur:0.08, thumpHz:85, thumpDur:0.28, pingHz:1400, tail:'hall',  tailMix:0.38},
    {name:'revolver_snap',crackHz:3200, crackQ:1.2, crackDur:0.05, thumpHz:110,thumpDur:0.20, pingHz:2200, tail:'plate', tailMix:0.28},
    {name:'distant_crack',crackHz:2400, crackQ:0.7, crackDur:0.07, thumpHz:70, thumpDur:0.18, pingHz:0,    tail:'hall',  tailMix:0.45, postLP:3500}
  ];
  let __sparkjoyKeyTimes=[]; const WPM_WINDOW_MS=2000;
  function markKeystroke(){ const now=performance.now(); __sparkjoyKeyTimes.push(now); const cutoff=now-WPM_WINDOW_MS; while(__sparkjoyKeyTimes.length && __sparkjoyKeyTimes[0]<cutoff){__sparkjoyKeyTimes.shift();} }
  function getWPM(){ const now=performance.now(), cutoff=now-WPM_WINDOW_MS; let count=0; for(let i=__sparkjoyKeyTimes.length-1;i>=0;i--){ if(__sparkjoyKeyTimes[i]>=cutoff) count++; else break; } const cps=count/(WPM_WINDOW_MS/1000); return (cps/5)*60 || 0; }
  function mapWPM(wpm){ const low=20, high=100, t=Math.max(0,Math.min(1,(wpm-low)/(high-low))); return {t, durMul:1-0.4*t, wetMul:1-0.5*t, pingMul:1-0.6*t}; }
  window.__sparkjoyWPM=getWPM; window.__mapWPM=mapWPM;

  let lastCaret={x:innerWidth/2,y:innerHeight/2};
  function caretClientPoint(){
    const sel=getSelection(); if(!sel || sel.rangeCount===0) return lastCaret;
    const range=sel.getRangeAt(0).cloneRange(); range.collapse(true);
    let rect=range.getClientRects()[0]||range.getBoundingClientRect();
    if(!rect || !(rect.width||rect.height)){
      const span=document.createElement('span'); span.style.display='inline-block'; span.style.width='0'; span.style.height='1em'; span.textContent='\u200b';
      range.insertNode(span); rect=span.getBoundingClientRect(); const r=document.createRange(); r.setStartAfter(span); r.collapse(true); const s2=getSelection(); s2.removeAllRanges(); s2.addRange(r); span.remove();
    }
    const x=rect.left+rect.width/2, y=rect.top+rect.height/2; lastCaret={x,y}; return lastCaret;
  }
      // === タイプライターモード（中央付近キープ） =========================
      const TYPEWRITER = {
        enabled: true,    // 必要なら設定タブからON/OFFしてもOK
        center: 0.5,      // 0.5 = 画面ちょうど中央（好みで 0.45 ~ 0.55 など）
        dead: 60          // 許容帯（px）。外れたときだけスクロール
          };
      
      let twRaf = 0;
  function keepCaretCentered(){
    if (!TYPEWRITER.enabled) return;
    // 可視ビューポート（モバイルのキーボード表示にも対応）
    const vv = window.visualViewport;
    const vTop = vv ? vv.offsetTop : 0;
    const vH   = vv ? vv.height   : window.innerHeight;
    const target = vTop + vH * TYPEWRITER.center;
    
    const p = caretClientPoint(); // 既存関数：キャレット位置（viewport座標）
    const bandMin = target - TYPEWRITER.dead;
    const bandMax = target + TYPEWRITER.dead;
    
    let dy = 0;
    if (p.y < bandMin) dy = p.y - bandMin;
    else if (p.y > bandMax) dy = p.y - bandMax;
    
    if (dy !== 0) {
      // ページスクロールを調整
      const sc = document.scrollingElement || document.documentElement;
      const newTop = Math.max(0, Math.min(sc.scrollHeight - vH, window.scrollY + dy));
      // 'auto' は即時。'smooth' にすると入力と競合して揺れる場合あり
      window.scrollTo({ top: newTop, behavior: 'auto' });
    }
  }
      // スケジューラ（連打でも1フレームにまとめる）
  function scheduleTW(){
    if (!TYPEWRITER.enabled) return;
    cancelAnimationFrame(twRaf);
    twRaf = requestAnimationFrame(keepCaretCentered);
  }
  function playGunshot(){
    if(!toggleSound.checked) return; ensureAudio(); resumeAudio();
    const a=audioCtx, now=a.currentTime, UIvol=(+soundVolEl.value/100);
    const R=Math.max(0,Math.min(1,(+realismEl.value||0)/100)), RV=Math.max(0,Math.min(1,(+reverbEl.value||0)/100));
    const v=window.__gunVariants[Math.floor(Math.random()*window.__gunVariants.length)];
    const m=mapWPM(getWPM());
    const crackDur=Math.max(0.03,Math.min(0.2, v.crackDur*(1.4-0.7*R))) * m.durMul;
    const crackQ=v.crackQ*(0.7+0.9*R);
    const thDur=v.thumpDur*(0.8+0.4*R) * m.durMul;
    const thAmp=0.8+0.4*R;
    const pingAmp=(v.pingHz?0.30*(1-0.85*R):0) * m.pingMul;
    const wetMix=(v.tailMix||0.3)*(0.25+0.75*R)*(0.2+1.8*RV) * m.wetMul;
    
    const panNode=a.createStereoPanner? a.createStereoPanner():null;
    if(panNode){ const pan=(lastCaret.x/innerWidth-0.5)*1.6; panNode.pan.setValueAtTime(Math.max(-1,Math.min(1,pan)), now); }

    const comp=a.createDynamicsCompressor();
    comp.threshold.setValueAtTime(-20-8*R,now); comp.knee.setValueAtTime(18+8*R,now); comp.ratio.setValueAtTime(2.5+3*R,now); comp.attack.setValueAtTime(0.003-0.001*R,now); comp.release.setValueAtTime(0.18-0.05*R,now);
    const out=a.createGain(); out.gain.setValueAtTime(UIvol,now);

    const crackSrc=a.createBufferSource(); crackSrc.buffer=noiseBuf; crackSrc.playbackRate.setValueAtTime(1+(Math.random()*0.2-0.1),now);
    const crackBP=a.createBiquadFilter(); crackBP.type='bandpass'; crackBP.frequency.setValueAtTime(v.crackHz,now); crackBP.Q.setValueAtTime(crackQ,now);
    const crackGain=a.createGain(); crackGain.gain.setValueAtTime(0.0001,now); crackGain.gain.exponentialRampToValueAtTime(1.0+0.2*R,now+0.002); crackGain.gain.exponentialRampToValueAtTime(0.0001,now+crackDur);
    crackSrc.connect(crackBP).connect(crackGain);

    const thOsc=a.createOscillator(); thOsc.type='triangle'; thOsc.frequency.setValueAtTime(v.thumpHz,now);
    const thGain=a.createGain(); thGain.gain.setValueAtTime(thAmp,now); thGain.gain.exponentialRampToValueAtTime(0.0001,now+thDur); thOsc.connect(thGain);

    let pingOsc=null,pingGain=null; if(v.pingHz && pingAmp>0){ pingOsc=a.createOscillator(); pingOsc.type='square'; pingOsc.frequency.setValueAtTime(v.pingHz*(0.95+Math.random()*0.1),now); pingGain=a.createGain(); pingGain.gain.setValueAtTime(pingAmp,now); pingGain.gain.exponentialRampToValueAtTime(0.0001,now+0.12); pingOsc.connect(pingGain); }

    const dry=a.createGain(), wet=a.createGain(); dry.gain.setValueAtTime(1,now); wet.gain.setValueAtTime(Math.min(1.0,wetMix*UIvol),now);
    const conv=a.createConvolver(); conv.buffer=irs? irs[v.tail]:null;
    const sum=a.createGain(); crackGain.connect(sum); thGain.connect(sum); if(pingGain) pingGain.connect(sum);
    let post=null; if(v.postLP){ post=a.createBiquadFilter(); post.type='lowpass'; post.frequency.setValueAtTime(v.postLP,now); }
    sum.connect(dry); sum.connect(conv); conv.connect(wet);
    const head=a.createGain(); head.gain.setValueAtTime(1,now);
    dry.connect(comp); wet.connect(comp); comp.connect(head);
    const last=post? (head.connect(post), post):head;
    if(panNode){ last.connect(panNode).connect(out).connect(a.destination); } else { last.connect(out).connect(a.destination); }
    crackSrc.start(now); crackSrc.stop(now+crackDur+0.02);
    thOsc.start(now);   thOsc.stop(now+thDur+0.05);
    if(pingOsc){ pingOsc.start(now); pingOsc.stop(now+0.15); }
  }
  ['pointerdown','keydown'].forEach(ev=>addEventListener(ev,()=>{ensureAudio();resumeAudio();},{once:true}));

  // IME（composition）: 変換中はカウントしないがFX/SFXは出す（60msスロットル）
  let isComposing=false, compBaseLen=0, lastCompFxAt=0;
  editor.addEventListener('compositionstart',()=>{ isComposing=true; compBaseLen=sanitizeText(editor.innerText||'').length; });
  editor.addEventListener('compositionend',()=>{
    const now=performance.now();
    const lenNow=sanitizeText(editor.innerText||'').length;
    const delta=Math.max(0,lenNow-compBaseLen);
    lastCountLen=lenNow; 
    isComposing=false;
    
    if(delta>0){
      cDeltaBuf.push({t:now,c:delta});
      const cutoff=now-ROLL_MS;
      while(cDeltaBuf.length&&cDeltaBuf[0].t<cutoff){cDeltaBuf.shift();}
      lastInputAt=now;
      const p = caretClientPoint();
      spawnSingleImpactAround(p.x, p.y);
      if(window.__lastSpeedLevel==='bad'){
        flashes.push({x:p.x,y:p.y,age:0,life:36,size:240*(Math.max(0.6,(+intensityEl.value)/100))});
      } else if(window.__lastSpeedLevel==='warn'){
        flashes.push({x:p.x,y:p.y,age:0,life:22,size:160*(Math.max(0.6,(+intensityEl.value)/100))});
        } 
      playGunshot();
      startStatsIfNeeded();
      updateStats();
    } else { 
      updateStats();
    }
    scheduleTW();
  });

  function crackAtCaret(){
    const jamP=Math.max(0,Math.min(1,(+jamEl.value||0)/100)); if(Math.random()<jamP) return;
    const p = caretClientPoint();
    spawnSingleImpactAround(p.x, p.y);
    playGunshot();
  }

  function onInput(ev){
    const type=ev&&ev.inputType||'', isPaste=type==='insertFromPaste'||type==='insertFromDrop', isCompType=/insertCompositionText|deleteCompositionText/.test(type)||(ev&&ev.isComposing);
    const now=performance.now(); const lenNow=sanitizeText(editor.innerText||'').length;

    if(isComposing||isCompType){
      const lenBefore=lastCountLen; lastCountLen=lenNow; lastInputAt=now;
      const isInsertish=type.startsWith('insert')||lenNow>lenBefore;
      if(isInsertish && (now-lastCompFxAt)>60){ crackAtCaret(); lastCompFxAt=now; }
      startStatsIfNeeded(); updateStats(); return;
    }

    const added=Math.max(0, lenNow-lastCountLen); lastCountLen=lenNow;
    if(!isPaste && added>0){ cDeltaBuf.push({t:now,c:added}); const cutoff=now-ROLL_MS; while(cDeltaBuf.length&&cDeltaBuf[0].t<cutoff){ cDeltaBuf.shift(); } }
    lastInputAt=now;
    if(!isPaste && added>0){ markKeystroke(); crackAtCaret(); }
    startStatsIfNeeded(); 
    updateStats();
    scheduleTW();
  }
  editor.addEventListener('input', onInput);
  modeSel && modeSel.addEventListener('change', updateStats);
  editor.addEventListener('focus',()=>{
    lastCaret=caretClientPoint();
    scheduleTW();
  });
      editor.addEventListener('click', scheduleTW);
      editor.addEventListener('keyup', (e)=>{
        if (e.key && /Arrow|PageUp|PageDown|Home|End/.test(e.key)) scheduleTW();
      });
  window.addEventListener('resize', scheduleTW);
  editor.setAttribute('role','textbox'); 
  editor.setAttribute('aria-multiline','true');
  editor.focus();
      // クリップボード（Clipboard API → フォールバック）
  async function copyTextToClipboard(text){
    // 1) 近代ブラウザ（https or PWA）
    try{
      if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function'){
        await navigator.clipboard.writeText(text);
        toast('コピーしました');
        return true;
      }
    }catch(_){}
    
    // 2) フォールバック（hidden textarea）
    try{
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.setAttribute('readonly','');
      ta.style.position = 'fixed';
      ta.style.top = '-1000px';
      ta.style.opacity = '0';
      document.body.appendChild(ta);
      ta.focus(); ta.select();
      const ok = document.execCommand('copy');
      document.body.removeChild(ta);
      if (ok){ toast('コピーしました'); return true; }
    }catch(_){}
    
    toast('コピーできませんでした');
    return false;
  }
      
      // ボタンに紐づけ
      if (copyBtn && !copyBtn.dataset.bound){
        copyBtn.dataset.bound = '1';
        copyBtn.addEventListener('click', async () => {
          const text = sanitizeText(editor?.innerText || '');
          await copyTextToClipboard(text);
        });
      }
      
      // お好みでショートカット（Ctrl/Cmd+Shift+C で全コピー）
      addEventListener('keydown', (e)=>{
        if ((e.ctrlKey||e.metaKey) && e.shiftKey && e.code==='KeyC'){
          const text = sanitizeText(editor?.innerText || '');
          copyTextToClipboard(text);
          e.preventDefault();
        }
      });
  
  // ---- Utils / Save / Clear ----
  function toast(msg){ try{ const t=document.createElement('div'); t.className='toast'; t.textContent=msg; document.body.appendChild(t); setTimeout(()=>t.remove(),1400);}catch(_){} }
  function sanitizeText(t){ return String(t||'').replace(/[​﻿]/g,''); }
  const IN_CANVAS=(function(){ try{ return self!==top; }catch(_){ return true; } })();

  function showSavePanel(text,filename){
    const overlay=document.createElement('div'); overlay.className='overlay';
    const box=document.createElement('div'); box.className='modal';
    const title=document.createElement('div'); title.textContent='保存'; title.style.cssText='font-weight:600;margin-bottom:8px';
    const note=document.createElement('div'); note.className='muted'; note.textContent='自動ダウンロードが制限されました。以下の方法で保存できます。';
    const area=document.createElement('div'); area.style.cssText='display:flex;flex-direction:column;gap:8px;margin:12px 0';
    try{ const blob=new Blob([text],{type:'text/plain;charset=utf-8'}); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.className='btn'; a.textContent='保存(.txt)'; a.href=url; a.download=filename; a.rel='noopener'; area.appendChild(a);
      overlay.addEventListener('click',(e)=>{ if(e.target===overlay){ try{URL.revokeObjectURL(url);}catch(_){ } document.body.removeChild(overlay);} });
    }catch(_){}
    const d=document.createElement('a'); d.className='btn'; d.textContent='新規タブで開く（Ctrl/Cmd+S）'; d.href='data:text/plain;charset=utf-8,'+encodeURIComponent(text); d.target='_blank'; d.rel='noopener'; area.appendChild(d);
    const ta=document.createElement('textarea'); ta.value=text; ta.rows=10; ta.style.cssText='width:min(80vw,680px);max-width:90vw;background:#0b0f14;color:#e6ecf3;border:1px solid rgba(255,255,255,.15);border-radius:8px;padding:8px';
    const copyBtn=document.createElement('button'); copyBtn.className='btn'; copyBtn.textContent='全選択してコピー';
    copyBtn.addEventListener('click', async()=>{ try{ await navigator.clipboard.writeText(text); toast('コピーしました'); }catch(_){ try{ ta.focus(); ta.select(); document.execCommand('copy'); toast('コピーしました'); }catch(_){ toast('コピーできませんでした'); } } });
    const close=document.createElement('button'); close.className='btn'; close.textContent='閉じる'; close.style.alignSelf='flex-end'; close.addEventListener('click',()=>{ document.body.removeChild(overlay); });
    area.appendChild(ta); area.appendChild(copyBtn); box.appendChild(title); box.appendChild(note); box.appendChild(area); box.appendChild(close); overlay.appendChild(box); document.body.appendChild(overlay);
  }
  function showSaveFallback(text,filename){
    const overlay=document.createElement('div'); overlay.className='overlay';
    const box=document.createElement('div'); box.className='modal';
    const msg=document.createElement('div'); msg.innerHTML='保存がブロックされました。下のリンクから保存してください。'; msg.style.marginBottom='12px';
    const area=document.createElement('div'); area.className='row';
    try{ const blob=new Blob([text],{type:'text/plain;charset=utf-8'}); const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.className='btn'; a.textContent='保存(.txt)'; a.href=url; a.download=filename; a.target='_blank'; a.rel='noopener'; area.appendChild(a);
      overlay.addEventListener('click',(e)=>{ if(e.target===overlay){ try{URL.revokeObjectURL(url);}catch(_){ } document.body.removeChild(overlay);} });
    }catch(_){}
    const d=document.createElement('a'); d.className='btn'; d.textContent='新規タブ表示'; d.href='data:text/plain;charset=utf-8,'+encodeURIComponent(text); d.target='_blank'; d.rel='noopener'; area.appendChild(d);
    const close=document.createElement('button'); close.className='btn'; close.textContent='閉じる'; close.addEventListener('click',()=>{ document.body.removeChild(overlay); });
    box.appendChild(msg); box.appendChild(area); overlay.appendChild(box); document.body.appendChild(overlay); toast('保存リンクを表示しました');
  }
// ---- ファイル名 ----

  async function saveNow(text){
    const filename=makeFilename();
    if(window.showSaveFilePicker){ try{
      const blob=new Blob([text],{type:'text/plain;charset=utf-8'});
      const handle=await window.showSaveFilePicker({suggestedName:filename,types:[{description:'Text',accept:{'text/plain':['.txt']}}]});
      const w=await handle.createWritable(); await w.write(blob); await w.close(); toast('保存しました'); return true;
    }catch(e){ /* continue */ } }
    try{
      const blob=new Blob([text],{type:'text/plain;charset=utf-8'});
      if(navigator && 'msSaveOrOpenBlob' in navigator){ /* IE */ // @ts-ignore
        navigator.msSaveOrOpenBlob(blob, filename); toast('保存処理を開始しました'); return true;
      }
      const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.rel='noopener';
      document.body.appendChild(a); a.click(); try{ a.dispatchEvent(new MouseEvent('click',{bubbles:true,cancelable:true,view:window})); }catch(_){ }
      setTimeout(()=>{ try{URL.revokeObjectURL(url);}catch(_){ } try{document.body.removeChild(a)}catch(_){ } }, 0);
      return true;
    }catch(_){}
    try{ const ok=window.open('data:text/plain;charset=utf-8,'+encodeURIComponent(text),'_blank'); if(ok){ toast('新規タブを開きました（Ctrl/Cmd+S で保存）'); return true; } }catch(_){}
    showSaveFallback(text, filename); return false;
  }

// === 全消去ダイアログ ===
function askClear(){
  const overlay = document.createElement('div'); overlay.className='overlay';
  const box = document.createElement('div'); box.className='modal';
  const msg = document.createElement('div'); msg.textContent='すべて削除しますか？'; msg.style.marginBottom='12px';
  const row = document.createElement('div'); row.className='row';
  const ok=document.createElement('button'); ok.className='btn'; ok.textContent='OK';
  const cancel=document.createElement('button'); cancel.className='btn'; cancel.textContent='キャンセル';
  row.appendChild(cancel); row.appendChild(ok); box.appendChild(msg); box.appendChild(row);
  overlay.appendChild(box); document.body.appendChild(overlay);
  const cleanup=()=>{ try{document.body.removeChild(overlay);}catch(_){ } };
  ok.addEventListener('click', ()=>{ cleanup(); doClear(); });
  cancel.addEventListener('click', cleanup);
  overlay.addEventListener('click', (e)=>{ if(e.target===overlay) cleanup(); });
}

function doClear(){
  editor.innerHTML='';
  // 画面エフェクトも消去
  if (typeof cracks!=='undefined'){ cracks.length=0; }
  try { ctx.clearRect(0,0,window.innerWidth, window.innerHeight); } catch(_){}
  // キャレットを先頭に戻す
  const sel = window.getSelection();
  if(sel){ try{ sel.removeAllRanges(); const r=document.createRange(); r.setStart(editor,0); r.collapse(true); sel.addRange(r);}catch(_){ } }
  editor.focus();
  // セッション終了（統計もリセット）
  if (typeof endSession==='function'){ endSession('clear'); }
  toast('クリアしました');
}




if (saveBtn && !saveBtn.dataset.bound) {
  saveBtn.dataset.bound = '1';
  saveBtn.addEventListener('click', async (ev) => {
    const text  = sanitizeText(editor?.innerText || '');
    const fname = makeFilename();

    // Shift+クリックなら「名前を付けて保存…」
    if (ev.shiftKey && window.showSaveFilePicker) {
      await saveWithPicker(text, fname);
      return;
    }

    // デフォルトは即ダウンロード
    try {
      forceDownload(text, fname);
      toast('ダウンロードを開始しました');
      return;
    } catch (_) {}

    // ブロック/失敗時のフォールバック
    if (window.showSaveFilePicker) {
      await saveWithPicker(text, fname);
    } else {
      showSaveFallback(text, fname);
    }
  });
}





  // クリア（既存の askClear/doClear をそのまま使用）
  if (clearBtn && !clearBtn.dataset.bound) {
    clearBtn.dataset.bound = '1';
    clearBtn.addEventListener('click', () => {
      if (typeof askClear === 'function') askClear();
      else if (typeof doClear === 'function') doClear();
    }, { passive:true });
  }

  if (resetSessionBtn && !resetSessionBtn.dataset.bound) {
    resetSessionBtn.dataset.bound = '1';
    resetSessionBtn.addEventListener('click', ()=> {
      if (typeof endSession === 'function') endSession('manual');
    }, { passive:true });
  }
})();



// ---- 簡易テスト（アンカーが作られるか） ----
window.__sjSaveSmoke = function(){
  let created = 0;
  const orig = document.createElement;
  document.createElement = function(tag){
    if (tag === 'a') created++;
    return orig.call(document, tag);
  };
  try {
    forceDownload('test', makeFilename());
  } finally {
    document.createElement = orig;
  }
  console.log('[save-smoke] anchors created:', created);
  return created; // 1 以上ならOK
};





</script>
</body>
</html>
